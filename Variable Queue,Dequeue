
MAX_QSIZE = 10
class CircleQueue:
    def __init__ (self):
        self.front=0
        self.rear=0
        self.items=[None]*MAX_QSIZE
    def isEmpty(self):
        return self.front ==self.rear

    def isFull(self):
        return self.front==(self.rear+1)%MAX_QSIZE

    def clear(self):
        self.front=self.rear

    def enqueue(self,item):
        if not self.isFull():
            self.rear = (self.rear+1)%MAX_QSIZE #rear 회전
            self.items[self.rear]=item

    def dequeue(self):
        if not self.isEmpty():
            self.front = (self.front+1)%MAX_QSIZE
            return self.items[self.front]
    
    def size(self):
        return(self.rear- self.front+MAX_QSIZE)%MAX_QSIZE

    def display(self):
        out=[]
        if self.front<self.rear:
            out = self.items[self.front+1:self.rear+1]
        else:
            out = self.items[self.front+1:MAX_QSIZE]+self.items[0:self.rear+1]
            print("[f=%s,r=%d===>"%(self.front,self.rear),out)

    
items=[None,None,"B","C","D",None,None,None]
q=CircleQueue()
for i in range(8):q.enqueue(i)
q.display()
for i in range(5):q.dequeue()
q.display()
for i in range(8,14):q.enqueue(i)
q.display()


map=[['1','1','1','1','1','1'],
      ['e','0','1','0','0','1'],
      ['1','0','0','0','1','1'],
      ['1','0','1','0','1','1'],
      ['1','0','1','0','0','x'],
      ['1','1','1','1','1','1']]
MAZE_SIZE=6
def valid(x,y):
    if x<0 or y<0 or x>=MAX_QSIZE or y>=MAX_QSIZE:
            return False
    else:
        return map[y][x]=='0' or map [y][x]=='x'

def BFS():
        q=CircleQueue()
        q.enqueue((0,1)) #튜플 
        print('BFS: ')

        while not q.isEmpty():
            here = q.dequeue() # 현재위치 ---큐에 들어간 가장 앞의자리가 나옴
            print(here,end='->')
            x,y= here 
            if (map[y][x]=='x'): return True
            else:
                map[y][x] = '.' #갔던 곳은 . 으로 표실함
                if valid(x,y-1):q.enqueue((x,y-1)) #상
                if valid(x,y+1):q.enqueue((x,y+1)) #하
                if valid(x-1,y):q.enqueue((x-1,y)) #좌
                if valid(x+1,y):q.enqueue((x+1,y)) #우
        return False

result =BFS()
if result:print('-->미로탐색 성공')
else : print('-->미로탐색 실패')

# 덱 클래스 구현
class CircleDeque(CircleQueue):
    def __init__(self):
        super().__init__()
    def addrear(self,item):self.enqueue(item)
    def deletefront(self):return self.dequeue() #반환에 주의
    def getfront(self):return self.peek()       #반환에 주의
    def addfront(self,item):
        if not self.isFull():
            self.items[self.front]=item #항목저장
            self.front=self.front-1
            if self.front<0:self.front=MAX_QSIZE-1
    def deleterear(self):
        if not self.isEmpty():
            item=self.items[self.rear]; #항목복사
            self.rear=self.rear-1
            if self.rear<0:self.rear=MAX_QSIZE-1
            return item
    def getrear(self):
        return self.items[self.rear]

dq=CircleDeque()
for i in range(9):
    if not i%2==0: dq.addrear(i)
    else: dq.addfront(i)
dq.display()
for i in range(2):dq.deletefront()
for i in range(3):dq.deleterear()
dq.display()
for i in range(9,14):dq.addfront(i)
dq.display()


D=CircleQueue()
D.enqueue(1)
D.enqueue(2)
D.enqueue(3)
D.enqueue(4)
D.enqueue(5)
D.enqueue(6)
D.enqueue(7)
D.enqueue(8)
D.display()



#우선순의 큐

class pdq():
    def __init__(self):   #생성자
        self.items=[]     #항목저장을 위한 리스트

    def isEmpty(self):            #공백상태 검사
        return len(self.items)==0

    def size(self):return len(self.items)   # 전체항목의 개수  

    def clear(self):self.items=[]  #초기화

    def enqueue(self,item):
        self.items.append(item)

    def findMaxIndex (self):
        if self.isEmpty(): return None
        else:
            highest=0
            for i in range(1,self.size()): 
                if self.items[i]>self.items[highest]:
                    highest=i
            return highest

    def dequeue(self):
        highest = self.findMaxIndex()
        if highest is not None:
            return self.items.pop(highest)
    
    def peek(self):
        highest = self.findMaxIndex()
        if highest is not None:
           return self.items[highest]
q=pdq()
q.enqueue(34)
q.enqueue(18)
q.enqueue(27)
q.enqueue(45)
q.enqueue(15)
print("PQueue",q.items)
while not q.isEmpty():
    print("MaX Priority= ",q.dequeue())
